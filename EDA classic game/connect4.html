<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Connect 4 vs CPU</title>
    <style>
        body {
            background: #000;
            color: #58fb00;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #board {
            margin: 20px auto;
            border-collapse: collapse;
        }
        #board td {
            width: 50px;
            height: 50px;
            border: 1px solid #222;
            background: #000;        /* empty cell */
            border-radius: 50%;
            cursor: pointer;
        }
        /* override color for players */
        #board td.p1 {
            background: #58fb00;      /* Player (you) â€“ green */
        }
        #board td.p2 {
            background: #ff0000;      /* CPU â€“ red */
        }
        #status {
            margin-top: 10px;
            font-weight: bold;
        }
        button {
            margin-top: 10px;
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid #58fb00;
            background: #000;
            color: #58fb00;
            cursor: pointer;
        }
        .scoreboard {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Connect 4 vs CPU</h1>
    <div>You are: <strong>Player 1 (Green)</strong> Â· CPU is: <strong>Player 2 (Red)</strong></div>
    <div>Current player: <span id="currentPlayerText">You</span></div>

    <table id="board"></table>

    <div id="status"></div>

    <div class="scoreboard">
        You Wins: <span id="c4PlayerWins">0</span> |
        CPU Wins: <span id="c4CpuWins">0</span> |
        Ties: <span id="c4Ties">0</span>
    </div>

    <button onclick="resetGame()">New Game</button>

    <p><a href="option2(1).html">â¬… Back to Arcade</a></p>
    
    <script>
        const ROWS = 6;
        const COLS = 7;

        let board = []; // 0 = empty, 1 = player, 2 = cpu
        let currentPlayer = 1; // 1 = you, 2 = CPU
        let gameOver = false;

        const boardEl = document.getElementById("board");
        const statusEl = document.getElementById("status");
        const currentPlayerText = document.getElementById("currentPlayerText");

        const c4PlayerWinsEl = document.getElementById("c4PlayerWins");
        const c4CpuWinsEl = document.getElementById("c4CpuWins");
        const c4TiesEl = document.getElementById("c4Ties");

        // --- localStorage helpers ---
        function loadInt(key, defaultVal) {
            const v = localStorage.getItem(key);
            return v !== null ? parseInt(v, 10) : defaultVal;
        }
        function saveInt(key, val) {
            localStorage.setItem(key, String(val));
        }

        let c4PlayerWins = loadInt("c4_playerWins", 0);
        let c4CpuWins    = loadInt("c4_cpuWins", 0);
        let c4Ties       = loadInt("c4_ties", 0);

        function updateScoreboard() {
            c4PlayerWinsEl.textContent = c4PlayerWins;
            c4CpuWinsEl.textContent = c4CpuWins;
            c4TiesEl.textContent = c4Ties;
        }

        function createBoard() {
            boardEl.innerHTML = "";
            board = [];

            for (let r = 0; r < ROWS; r++) {
                const row = [];
                const tr = document.createElement("tr");

                for (let c = 0; c < COLS; c++) {
                    row.push(0);

                    const td = document.createElement("td");
                    td.id = "cell-" + r + "-" + c;
                    td.dataset.row = r;
                    td.dataset.col = c;

                    // clicking ANY cell in this column = your move
                    td.addEventListener("click", onPlayerClick);

                    tr.appendChild(td);
                }

                board.push(row);
                boardEl.appendChild(tr);
            }
        }

        function onPlayerClick(e) {
            if (gameOver || currentPlayer !== 1) return; // only on your turn

            const col = parseInt(e.target.dataset.col);
            if (!dropPiece(col, 1)) {
                statusEl.textContent = "That column is full. Choose another.";
                return;
            }
            drawBoard();

            if (handleEndOfMove(1)) return; // checks win/tie and switches turn

            // CPU's turn
            cpuMove();
        }

        function getLowestEmptyRow(col) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === 0) return r;
            }
            return -1;
        }

        // place piece for player in given column, returns row or -1
        function dropPiece(col, player) {
            const row = getLowestEmptyRow(col);
            if (row === -1) return false;
            board[row][col] = player;
            return row;
        }

        function cpuMove() {
            if (gameOver) return;

            // Simple CPU AI:
            // 1) try winning move
            let col = findBestMoveForPlayer(2);
            // 2) block your winning move
            if (col === -1) col = findBestMoveForPlayer(1);
            // 3) prefer center-ish column
            if (col === -1) {
                const preferred = [3, 2, 4, 1, 5, 0, 6];
                for (const c of preferred) {
                    if (getLowestEmptyRow(c) !== -1) {
                        col = c;
                        break;
                    }
                }
            }
            // 4) if still -1, all columns full (should be tie)
            if (col === -1) {
                if (isBoardFull()) {
                    endAsTie();
                }
                return;
            }

            const row = dropPiece(col, 2);
            if (row === false) return;
            drawBoard();

            handleEndOfMove(2, row, col);
        }

        // simulate moves for simple AI
        function findBestMoveForPlayer(player) {
            for (let c = 0; c < COLS; c++) {
                const r = getLowestEmptyRow(c);
                if (r === -1) continue;
                board[r][c] = player;
                const win = checkWin(r, c, player);
                board[r][c] = 0;
                if (win) return c;
            }
            return -1;
        }

        function drawBoard() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.getElementById("cell-" + r + "-" + c);
                    cell.className = "";
                    if (board[r][c] === 1) cell.classList.add("p1");
                    else if (board[r][c] === 2) cell.classList.add("p2");
                }
            }
        }

        function isBoardFull() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] === 0) return false;
                }
            }
            return true;
        }

        function checkWin(row, col, player) {
            function countDir(dr, dc) {
                let count = 0;
                let r = row + dr;
                let c = col + dc;
                while (
                    r >= 0 && r < ROWS &&
                    c >= 0 && c < COLS &&
                    board[r][c] === player
                ) {
                    count++;
                    r += dr;
                    c += dc;
                }
                return count;
            }

            const directions = [
                [0, 1],   // horizontal
                [1, 0],   // vertical
                [1, 1],   // diag down-right
                [1, -1]   // diag down-left
            ];

            for (const [dr, dc] of directions) {
                let total = 1; // include placed piece
                total += countDir(dr, dc);
                total += countDir(-dr, -dc);
                if (total >= 4) return true;
            }
            return false;
        }

        function handleEndOfMove(player, lastRow, lastCol) {
            // lastRow/lastCol sometimes omitted for player=1 (we can recompute quickly)
            if (lastRow === undefined || lastCol === undefined) {
                // find any cell of that player in bottom-most rows.
                outer:
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c] === player) {
                            lastRow = r;
                            lastCol = c;
                            break outer;
                        }
                    }
                }
            }

            if (checkWin(lastRow, lastCol, player)) {
                if (player === 1) {
                    statusEl.textContent = "You win! ðŸŽ‰";
                    c4PlayerWins++;
                    saveInt("c4_playerWins", c4PlayerWins);
                } else {
                    statusEl.textContent = "CPU wins! ðŸ¤–";
                    c4CpuWins++;
                    saveInt("c4_cpuWins", c4CpuWins);
                }
                gameOver = true;
                updateScoreboard();
                return true;
            }

            if (isBoardFull()) {
                endAsTie();
                return true;
            }

            currentPlayer = (player === 1 ? 2 : 1);
            updateCurrentPlayerText();
            return false;
        }

        function endAsTie() {
            statusEl.textContent = "It's a tie!";
            gameOver = true;
            c4Ties++;
            saveInt("c4_ties", c4Ties);
            updateScoreboard();
        }

        function updateCurrentPlayerText() {
            if (currentPlayer === 1) {
                currentPlayerText.textContent = "You";
            } else {
                currentPlayerText.textContent = "CPU";
            }
        }

        function resetGame() {
            gameOver = false;
            currentPlayer = 1;
            statusEl.textContent = "";
            updateCurrentPlayerText();
            createBoard();
            drawBoard();
        }

        // init
        updateScoreboard();
        resetGame();
    </script>
</body>
</html>
